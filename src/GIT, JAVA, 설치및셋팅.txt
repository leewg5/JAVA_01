[ 인텔리제이 깃허브 연동 ]
    1. 인텔리제이 상단메뉴 -> [ 파일 ] -> [설정]
    2. 사이드메뉴 [ 버전관리 ] -> [github]
    3. [계정추가] --> github통해 --> 웹 깃허브 로그인후 인증

[ 인텔리제이 깃허브 커밋계정 정보 ]
    1. 인텔리제이 왼쪽 하단 메뉴 [ 터미널 : alt+f12]
    2. 터미널 상단 [v] 아이콘클릭 --> [git bash]
        git config --global user.name 본인깃아이디
        git config --global user.email 본인깃이메일

[ 인텔리제이 에서 깃허브에 프로젝트 게시하기 ]
    1. 인텔리제이 상단메뉴 -> [ VCS ]
    2. [ Github 프로젝트 공유 ]
        - 저장소 이름 : 프로젝트명(*아무거나) !!! [체크안함] 비공개
        - 원격 : (기본값)
    3. 최초 커밋 파일 ( 메시지는 아무거나 )

[ 커밋/푸시 하는 방법 ]
    1. 인텔리제이 왼쪽 메뉴 -> [커밋]
    2. 커밋할 파일들을 체크하고 하단에 메시지 작성
    3. [ 커밋 및 푸시 ] 클릭

[ 집/pc변경시 : 기존 프로젝트 클론/복제]
   1. 인텔리제이 첫 화면 -> [저장소 복제]
   * 왼쪽사이드메뉴 -> [github] 계정없음 -클릭후-> 계정추가
   2. 복제할 저장소명을 검색해서 [복제]

[ 깃 저장소 삭제 ]
    1. 삭제할 저장소의 github 웹페이지 예시]https://github.com/itdanjalog/test22
    2. 저장소 [Settings] 메뉴 클릭후
    3. 스크롤 쭉 내리면 'Danger Zone' : Delete this repository

==================================================
[ 자리 이동 전 ]
1. 현재 프로젝트 에서 최종적으로 커밋/푸시 한다.

2. 인텔리제이 에서 깃 로그아웃 방법
    1) 상단메뉴 -> [파일] -> [설정]
    2) 사이드메뉴 -> [버전관리] -> [ github]
    3) 로그인 내 깃 정보(아이콘) 클릭후 -> [-]제거 -> [적용] -> [확인]

3. 인털리제이 에서 작업한 프로젝트 삭제 방법
    1) 인텔리제이 종료후 -> 작업프로젝트 삭제

4. pc카톡 / 크롬(구글) /깃허브웹 등등 자동로그인 해지 및 로그아웃 하기

[ 자리 이동 후 ]
1. 인텔리제이 / MySQL Workbench 8.0 CE 설치 확인
2. 인텔리제이 실행후 내 프로젝트 가져오기
	1) 인텔리제이 최초 실행화면 --> [저장소 복제]
 	2) 왼쪽메뉴 --> 계정없음 --> [GitHub를 통해 로그인] -> 웹 인증
	3) 내 저장소에서 가져올 깃 저장소명 선택하여 --> [복제]

3. 깃허브의 commit 계정 수정 하기
	1) 인텔리제이 왼쪽 하단 메뉴 [ 터미널 : alt+f12]
   	2) 터미널 상단에 [v] 아이콘클릭 --> [git bash]
        		git config --global user.name 본인깃아이디
        		git config --global user.email 본인깃이메일

-----------------------------------------------------------------------
[ 파일 만들기 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기]
        1. java 클래스
        2. 파일 ( 파일명.txt )
        3. 패키지 ( 폴더 )

[ 자바 클래스 파일 생성 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기] -> [ 패키지 ] -> (강의기준 day01~ )
    3. [특정폴더] 오른쪽 클릭 -> [ 새로만들기 ] -> [java클래스]
        * 클래스 파일 명은 첫글자를 무조건 대문자로 시작.
        예) Example1

[ 자바 구동 원리 ]
    1. [코딩] 개발자는 .java 파일내 자바 문법 작성한다.
    - Example1.java ( 파일 )
    2. [실행] .java 파일 -- 컴파일(번역/해석) ---> .class 파일(바이트) 생성
    3. [처리] (컴퓨터가) .class 파일 처리한다.

[ 주석 ]
    HTML : <!-- 주석처리 -->
    CSS : /* 주석처리 */
    JS/JAVA :   // 한줄주석
                /*  여러줄주석 */

[ 자바 활용처 ]
    1. 소프트웨어 : javafx툴 활용, 등등
    2. 웹 : JSP , Spring 등등
    3. 앱 : 안드로이드 등등

[ 자바 코드 실행 ]
    - 자바는 클래스 단위로 컴파일 되고 , 컴파일된 코드는 main함수 부터 읽어서(스레드) 처리한다.

[ 리터럴 ]
    - 3 , 3.14 , 'a' , "ABC" , true 등등
    1. 정의 : 키보드 로 부터 입력한 자료
    2. 종류
        정수(int) , 실수(double) , 문자('') , 문자열("") , 논리(boolean)

[ 기본타입 ]
    1. 정의 : 자료들의 분류
    2. 목적 : 효율적인 자료 처리 (*분리수거)
    3. 종류(8가지)
        [정수]       byte        1바이트        -128 ~ 127
                    short       2바이트        +-3만정도 까지
                    int         4바이트        +-21억정도 까지 (*리터럴정수)
                    long        8바이트        +-21억정도 이상 , 리터럴정수 뒤에 L/l 붙이기
        [실수]       float       4바이트        소수점8자리 표현 , 리터럴실수 뒤에 F/f 붙이기
                    double      8바이트        소수점17자리 표현(*리터럴실수)
        [논리]       boolean     1바이트        true/false
        [문자]       char        2바이트        유니코드 , ' '작은따옴표 감싼 문자1개
                    *String     클래스         클래스 , " " 큰따옴표 감싼 문자여러개
[출력함수]
    1. System.out.print();                                      : 출력
    2. System.out.println();                                    : 출력후 줄바꿈
    3. System.out.printf( "형식문자1 형식문자2" , 값1 , 값2 );    : 서식(형식) 맞춤 출력
        - 형식문자 : %s 문자열 , %d 정수 , %c 문자 , %f 실수
        - 자릿수 :
            %자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 오른쪽 정렬
            %-자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 왼쪽 정렬
            %0자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 0채움
        - 소수점 자릿수 :
            %전체자릿수.소수점자릿수f : (소수점포함)전체 자릿수 만큼 자릿수 차지

[ 이스케이프/제어 문자 ] : 특수문자에 기능이 포함
    \n 줄바꿈 , \t 들여쓰기 , \\ 백슬래시 출력 , \' 작은따옴표 출력 , \" 큰따옴표 출력

[ (변수)타입변환 ] , **다형성**
    1. 자동(묵시적) 타입변환
        (1) byte -> short/char -> int -> long -> float -> double
        (2) 메모리 크기가 작은 것 에서 큰 것으로 변환 가능!
        (3) 연산결과
            - 두 항 중에 더 큰 항의 타입으로 결과 반환
            - 단] int 이하는 무조건 int 반환
    2. 강제(명시적) 타입변환
        (1) double -> float -> long -> int -> short/char -> byte
        (2) 메모리 크기가 큰 것 에서 작은 것으로 변환 가능!
        (3) (변환할타입명)변수명;
        (4) !! 자료의 손실이 생길 수 있다.

[ 입력함수 ]
    1. 콘솔화면에서 키보드로 부터 입력받는 방법
    2. 사용법
        (1) 입력객체 생성 : new Scanner( System.in);
            Scanner 변수명 = new Scanner( System.in);
            * 주의할점 : Scanner 입력시 자동완성 권장. 안할경우 : 클래스 위에 import java.util.Scanner; 직접 작성
            * import란 다른 클래스(코드정보) 호출
        (2) 입력함수
            .next()             : 입력받은 자료를 문자열(String)로 반환 , 띄어쓰기 불가능
            .nextLine()         : 입력받은 자료를 문자열(String)로 반환 , 띄어쓰기 가능 ,
                * 문제점 : .nextLine() 앞 코드 에 다른 next() 존재할 경우 의미없는 nextLine() 필요하다.
            .nextByte()         : 입력받은 자료를 정수(byte)로 반환
            .nextShort()        : 입력받은 자료를 정수(short)로 반환
            .nextInt()          : 입력받은 자료를 정수(int)로 반환
            .nextLong()         : 입력받은 자료를 정수(long)로 반환
            .nextFloat()        : 입력받은 자료를 실수(float)로 반환
            .nextDouble()       : 입력받은 자료를 실수(double)로 반환
            .nextBoolean()      : 입력받은 자료를 논리(boolean)로 반환
            .next().charAt(0)   : 입력받은 자료를 첫글자 문자(char)1개 반환
[ 연산자 ]
    1. 산술연산자 : +더하기 -빼기 *곱하기 /나누기 %나머지
    2. 연결연산자 : +연결
    3. 비교연산자 : >초과 >=이상 <미만 <=이하 ==같다 !=같지않다
    4. 논리연산자 : &&이면서 ||이거나 !부정
    5. 증감연산자 : ++변수명 변수명++ --변수명 변수명--
    6. 대입연산자 : =대입 +=더한후대입 연산후대입(+= *= -= /= %= )
    7. 삼항연산자 : 조건 ? 참 : 거짓
    8. 문자열비교 : "문자열A".equals("문자열B")

[ 조건문 ]
    1. 조건에 따른 결과(true/false)의 코드 흐름 제어 ,
    2. 종류)
        (1) if( 조건문 ) 참일때명령어;
        (2) if( 조건문 ){ 참일때명령어1; 참일때명렁어2; }
        (3) if( 조건문 ){ 참일때명령어; }
            else{ 거짓일때명령어; }
        (4) if( 조건문1 ) { 참1일떄명령어;}
            else if( 조건문2 ) { 참2일때명령어; }
            else if( 조건문3 ) { 참3일때명령어; }
            else{ 거짓일때명령어; }
        (5) if( 조건문1 ) { 참1일때명령어; }
            if( 조건문2 ) { 참2일때명령어; }
            if( 조건문3 ) { 참3일때명렁어; }
        (6) if( 조건문1 ) {
                if( 조건문2 ){ }
                else{ }
            }else{ }

[ 배열 ]
    1. 정의 : *동일한* 자료형(타입)의 여러개 자료들을 순서대로 저장하는 자료의 타입
    2. 특징
        1) 동일한 타입 : 서로 다른 자료형(타입) 데이터는 같은 배열에 저장 불가능
        2) *고정 길이* : 배열은 한 번 선언(생성)되면 길이/크기/요소 개수 수정 할 수 없음. < 요소 추가/삭제 없다. >
        3) 요소 기본값 : 배열내 요소의 초기값이 없으면 자동으로 기본값
            - 정수 : 0 , 실수 : 0.0 , 논리 : false , 객체 : null
        4) 인덱스 : 배열내 저장된 요소들의 순서번호 , 0번 시작
    3. 사용법
        1) 선언/생성
            (방법1) new 타입[길이];     , int[] 변수명 = new int[3];
            (방법2) { 값1, 값2, 값3 }  , double[] 변수명 = { 3.14, 5.1, 78.62 }
        2) 호출
            (1) 변수명                         , 배열의 주소값 반환
            (2) Arrays.toString( 변수명 );     , 배열내 요소 값들을 문자열로 반환
            (3) 변수명[인덱스]                  , 배열내 특정한 요소 값 반환
            (4) 변수명.length                  , 배열내 요소 개수 반환
        3) 요소 추가/삭제 없음.
        4) 배열과 반복문
            (1) 일반 for문 : 인덱스가 있는 배열내 요소값들을 하나씩 순회
                for( int index = 0 ; index <= 배열변수명.length - 1 ; index++ ){
                    타입 반복변수명 = 배열변수명[index];
                }
            (2) 향상된 for문 : 인덱스 없이 배열내 요소값들을 하나씩 순회
                for( 타입 반복변수명 : 배열변수명 ){

                }

[ 클래스 와 객체 ]
    * 자바는 컴파일(번역)을 클래스 단위로 처리한다.
    1) 정의
        (1) 객체      : '주체'가 아닌 의사나 행위를 미치는 대상
        (2) 클래스    : 객체를 만들기 위한 객체를 정의하는 *설계도*
    2) 클래스 멤버
        (1) 멤버변수    : 객체내 포함할 변수 , 속성/특징/성질     = 값/데이터
        (2) 메소드     : 객체내 포함할 함수 , 이벤트/행위/작동    = 실행명령어집합
        (3) 생성자     : 객체가 생성될때 초기화함수 , 초기화
    3) 클래스 사용법
        (1) 선언하는 방법 : 1. .java파일내 여러개 클래스 존재[비권장] 2. .java파일내 클래스는 1개 존재[권장]
            class 클래스명{
                멤버변수;
                생성자;
                메소드;
            }
    4) 객체 사용법
        (1) 객체 선언하는 방법
            new 클래스명();         ,   클래스명 변수명 = new 클래스명();
            * new 연산자 : 클래스 기반으로 새로운 객체를 생성하며 메모리를 1개 할당하는 키워드
        (2) 객체내 멤버변수 호출
            변수명.멤버변수명
            * . 접근연산자 : 객체내 포함된 멤버변수,메소드 등 접근하는 키워드
        (3) 객체내 멤버변수 값 수정
            변수명.멤버변수명 =  새로운값
        (4) 객체내 멤버변수 추가/삭제 불가능 : 클래스는 컴파일(실행/번역)된 이후에 추가/수정이 불가능

[ 메소드 : 기능 사용법 ]
    1. 정의 : 하나의 기능을 수행하는 일련의 명령어/코드 들
    2. 용어 :
        1) 인수/인자 값      : 메소드 호출시 메소드에게 전달되는 값
            예) 변수명.메소드명( *인수1* , *인수2* );
        2) 매개변수         : 메소드 실행될때 인수/인자 값을 대입 받는 변수
            예) void 메소드명( 타입 매개변수1 , 타입 매개변수2 );
            -> 주의할점 : 1.인자값 과 매개변수의 타입 일치 해야한다.!!! , 사용법 규칙
                         2. 매개변수 없을 수 도 있다.
                         3. 지역변수 특징
        3) 반환 값          : 메소드 종료될때 메소드를 호출했던 곳으로 되돌려주는 값
            예) return 반환값;
        4) 반환 타입        : 반환 값의 자료형/타입
            예) 반환타입 메소드명() { }
            -> 주의할점 : 1. 반환값 과 반환타입의 타입 일치 해야한다.!!!
                         2. 반환값은 항상 자료 1개만 가능하다.
                         3. 반환값이 없을때는 void 타입의 키워드 사용한다.
    3. 사용법
        1) 정의/만들기
            반환타입 메소드명( 타입 매개변수1 , 타입 매개변수2 ··· ){
                실행코드;
                return 반환값;
            }
        2) 호출/사용하기
            방법1) 호출하고자 하는 메소드가 다른 클래스 일때
                (1) 객체생성 : 클래스명 변수명 = new 클래스명();
                (2) 객체통해 메소드 호출 : 변수명.메소드명(인수1,인수2);
            방법2) 호출하고자 하는 메소드가 같은 클래스 일때
                (1) 메소드명( 인수1,인수2 );

[ 생성자 ]
    1. 정의 : 객체(인스턴스)를 생성(new) 할때 사용되는 초기화 메소드
    2. 규칙
        1) 클래스명과 생성자명은 동일하다.
        2) 오버로드 : 매개변수의 개수/타입/순서 가 다르면 동일한 이름으로 여러개 선언
    3. 종류
        1) 기본생성자 : 매개변수 없는 생성자
            - 클래스내 생성자가 하나도 존재 하지 않으면 컴파일(실행)될때 자동 생성
        2) 생성자 : 주로 매개변수 있는 생성자
            - 메소드와 다르게 반환타입/값 없다.
    4. 목적 : 객체 생성시 멤버변수에 빠른 초기화 혹은 유효성 검사( 규칙적인 초기화 )
    5. 사용법
        1) 선언/정의 방법
            class 클래스명{
                생성자명( ){ }
            }
        2) 호출/사용 방법
            new 생성자명();

[ 주요 키워드 ]
    1. 접근제한자 : 다른 클래스가 특정한 클래스에 접근할때 제한
        1) public       : *모든 클래스* 에서 접근 가능
        2) private      : *현재 클래스* 에서만 접근 가능
        3) (default)    : 같은 *패키지* 에서만 접근 가능 , 키워드는 생략
        4) protected    : 같은 *패키지* 에서만 접근 가능 , 상속관계 예외
    2. 클래스 불러오기
        1) import       : 현재 클래스에서 다른 패키지의 클래스 불러올때 , 라이브러리(남이만든클래스)
    3. 상수
        1) final        : 초기화(선언) 이후에 *수정* 불가능 상태
        2) static       : (전역변수) 프로그램 실행시 *우선 메모리할당* 되고 프로그램 종료될때 메모리삭제, (객체없이가능)
[ 관례적 용어 ]
    1. setter and getter    : 멤버변수가 private 으로 선언될 경우 다른 클래스로부터 간접접근 메소드
    2. public static final  : (상수) 프로그램내 딱1개만 존재하는 값 선언할때
[ 구분할 용어들 ]
    1. 변수는 선언된 위치 또는 키워드에 따라 다르다.
        멤버변수 : 객체 속성(메소드밖에 선언된 )
            class 클래스{ int a; }
        지역변수 : 메소드 안에서 선언된
            class 클래스{ void 메소드(){ int a; } }
        매개변수 : 메소드 호출시 전달받은 인수/인자값 저장한 변수
            class 클래스{ void 메소드(int a){} }
        정적변수 : 멤버변수 앞에 static
            class 클래스{ static int a; }

        *상수 :

    2.
        객체       : 속성과 기능을 구성하는 물리적/논리적 추상 ( 논리적 개념 )
        클래스     :  객체를 생성하기 위한 설계도
        인스턴스    : 속성과 기능을 생성된 형태 ( 물리적 개념 ) , new

[ 상속 ]
    1. (상위) 클래스 로부터 (하위) 클래스 에게 (멤버변수/메소드)를 물려주는 행위
    2. 특징
        1. 하위 클래스가 객체(인스턴스) 생성하면 상위 클래스 객체(인스턴스) 도 생성.
        2. **다형성**
            1) 하위 클래스/타입 에서 상위 클래스/타입 으로 변환 가능 ( 자동타입변환 )
            2) 상위 클래스/타입 에서 하위 클래스/타입 으로 변환 가능 ( 강제타입변환 )
    3. extends
        - class 상위클래스{}
        - class 하위클래스 extends 상위클래스{ }

[ 인터페이스 ]
    1. 인터페이스 로부터 클래스가 (추상메소드)를 물려받아 *구현* 하는 행위
    2. 특징
        1. 인터페이스는 *상수 와 *추상메소드 를 갖는다. 즉] 생성자 없어서 자체적으로 객체(인스턴스) 생성 불가능
        2. **다형성**
            1) 인터페이스를 구현한 클래스/타입 에서 인터페이스 타입으로 변환 가능 ( 자동타입변환 )
    3. implements
        - interface 인터페이스{ }
        - class 구현클래스 implements 인터페이스1 , 인터페이스2{ }

[ 다형성 ]
    1. 다양한 형태/타입 갖는 성질 , 값/객체를 변경하는게 아니다.
    2. 상속 과 인터페이스 표현
    3. @오버라이딩 : 상속 또는 인터페이스 에서 물려받은 메소드를 재구현(상속) 또는 구현(인터페이스) 하는 행위
        ** 타입간의 중복된 메소드가 존재할 경우 오버라이딩된 메소드가  최우선으로 실행된다.
    4. 확인
        객체 instanceof 타입

[ 인스턴스 ]
    1. 인스턴스(객체) 는 클래스(설계도) 기반으로 메모리(컴퓨터저장소) 생성한다.
    2. 인스턴스(객체) 마다 의 멤버변수를 메모리 에 각각 생성한다.
    3. 클래스의 메소드는 모든 인스턴스(객체) 공유 한다.
    ----------------------------------------------------------------
    클래스/정적(메모리)                         힙(메모리)
    class Member{                       new Member : int age = 10;
        int age ;
        void event(){                   new Member : int age = 30;
        }
    }

[ 입출력 ] 입력(컴퓨터 안으로 ) , 출력(컴퓨터 밖으로 )
[ 파일 ] 컴퓨터에 사용되는 데이터들을 모아놓은 것
[ 스트림 ] 컴퓨터내 데이터/자료 가 다니는 통로
    * 데이터 가 다니는 통로인 스트림은 *바이트 단위* 이동
    * 영문/특수문자 1글자당 : 1바이트 , 한글 1글자당: 3바이트

[ 바이트 ] 컴퓨터가 처리 하는 *용량 단위*
    1. 비트 : 0 또는 1
    2. 바이트 : 0 1 0 1 0 1 0 1 ( 8개 BIT -> 1BYTE )
    3. 8bit -> 1024byte -> 1024kbyte -> 1024mbyte

[ 파일 입출력 ] , 예외처리 무조건 발생한다.
    - 목적 : 자바내 모든 메모리는 영구저장 아니다. <휘발성메모리>
    1. FileOutputStream 클래스
        1) .write( 바이트배열 )      : 지정한 바이트 배열을 지정된 파일로 쓰기 함수
    2. FileInputStream 클래스
        1) .read( 바이트배열 )       : 지정한 바이트 배열에 읽어온 파일들을 읽기 함수

[ 문자열 관련 메소드 ]
    1. "문자열".getBytes()             : 문자열 을 바이트배열로 반환 함수
    2. new String( 바이트배열 )         : 바이트배열 을 문자열로 반환 함수
    *3. "문자열".equals( "문자열" )     : 문자열 비교 결과 반환 함수

-----------------------------------------------------------------------------------------
[ 무료 데이터베이스 ]
    1.  https://freedb.tech/
    2. [ Get Started ]
    3. 회원가입 진행 후
        -------------------
        About : User(아무거나)
        Use Case Of Database : User(아무거나)
        full name : User(아무거나)
        --------------------
    4. 로그인
    5. [ Dashboard ]
        Host : 확인
        Port : 3306
        Database Name: 확인
        Password : 확인

[ MYSQL WorkBench ]
    1. 실행 ->>  상단메뉴 ->> [database] ->> connect database
    2.
        connect name : 아무거나
        connect method : standard
        host name : [ Dashboard ]확인한 host
        port : 3306(고정)
        username : [ Dashboard ]확인한 Database Name
        password : [ Dashboard ]확인한 password
        [ OK ]

[ DAO 에서 DB 정보 수정 ]
    (1) 로컬 환경
    private String db_url = "jdbc:mysql://localhost:3306/exam10";
    private String db_user = "root";
    private String db_password = "1234";

    (2) freeDB 클라우드 환경 , 주의할점 : 깃허브를 private 하기.
    private String db_url = "jdbc:mysql://sql.freedb.tech:3306/freedb_itdanja";
    private String db_user = "freedb_itdanja";
    private String db_password = "KkNNeers8!p!QZ*";

[ 프로젝트 --> .jar 파일 생성 ]
    1. 인텔리제이 상단 메뉴 -> [파일] -> [ 프로젝트 구조 ]
    2. 왼쪽 메뉴 -> [아티팩트]클릭 -> [+] -> [JAR] -> [종속성 포함 모듈에서]
    3.
        메인클래스 : JAR변경할 클래스선택
        [OK]
    4. [적용] -> [확인]
    5. 인텔리제이 상단 메뉴 -> [빌드] -> [아티팩트 빌드] -> [빌드]
    6. 확인 : 프로젝트 폴더내 -> out폴더 -> artifacts폴더-> tj2025A_backend.jar

[ .jar 파일 --> .exe 파일 생성 ]
    1. https://sourceforge.net/projects/launch4j/files/launch4j-3/3.50/
    2. [launch4j-3.50-win32.exe] 다운로드 클릭
    3. 설치 진행
    4. launch4j 실행 <----------- 현재 운영체제에 java 설치된 환경 가능!
        [basic] 탭
            output file : .exe 파일 경로 지정 , 예) C:\Users\tj-bu-702-teacher\Desktop\consoleProgram.exe
            jar : 생성된 .jar 파일 경로
        [Header] 탭
            header type : console
        [JRE] 탭
            min jre version : 1.8
    5. 상단 메뉴에 톱니바퀴[아이콘] 클릭 -> 설정파일 저장(아무거나) ->  하단 log창에 'Successfully' 출력되면 성공

[ java 설치 ]
    1. jdk17 : https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html
    2. Windows x64 Installer	153.92 MB
       https://download.oracle.com/java/17/archive/jdk-17.0.12_windows-x64_bin.exe (sha256 ) 클릭
    3. 설치 진행
    4. 확인 : cmd(명령프롬프트) --> java -version 입력후 엔터
        java version "17.0.12" 2024-07-16 LTS
        Java(TM) SE Runtime Environment (build 17.0.12+8-LTS-286)
        Java HotSpot(TM) 64-Bit Server VM (build 17.0.12+8-LTS-286, mixed mode, sharing)

-----------------------------------------------------------------------------------------------
[ 디자인 패턴 ]
    1. 패턴 이란 : 되풀이되는
    2. 디자인 패턴 : 소프트웨어 설계 과정에서 자주 발생하는 문제점/설계 유형
    3. 학습할 패턴 종류
        1) 싱글톤 패턴
        2) MVC 패턴
    4. 목적 : 여러 개발자들이 협업간의 관례적인 규칙(패턴)으로 개발의 효율성 높인다.
[ 싱글톤 ]
    1. 정의 : 프로그램내 객체(인스턴스)가 단 하나만 존재하는 설계
    2. 목적 : 하나의 객체(인스턴스)를 만들고 공유
        - 여러개의 객체가 존재하면 서로 다른 메모리를 사용하므로 공유하는데 제약이 있다.
        - 협업에 있어서 굳이 여러개 객체(인스턴스)가 필요 없는 경우가 있다.
    3. 싱글톤 만드는 방법
        단계1) 지정한 클래스에 기본 생성자를 private 한다.
            private 생성자명(){}
        단계2) 지정한 클래스에 private static final 으로 객체(인스턴스) 선언한다.
            private static final 클래스명 변수명 = new 생성자명();
        단계3) 지정한 클래스에 public static 으로 getInstance 메소드 선언한다.
            public static 클래스명 getInstance(){
                return 변수명;
            }
    4. 다른 클래스에서 싱글톤 호출하기.
        클래스명.getInstance();

[ MVC 패턴 ]
    1. 정의 : (웹/앱)소프트웨어 개발에서 사용되는 디자인패턴으로 세가지 주요 역할을 분리하여 코드의 모듈화(조각) 와 유지보수 높인다.
    2. 목적 : 프로젝트 협업간의 코드와 파일들을 MVC패턴의 따라 구성하여 효율성을 높인다.
    3. 장점 : 유지보수 , 모듈화 , 단일기능책임 등
    4. 단점 : 분리함에 따라 관리 복잡도 높다.
    5. 예]
        (1) 1인식당 : 사장님이 혼자서 서빙하고 요리 하고 재료준비 한다.
            ( 식당의 규모가 커지면 감당이 안된다.)
        (2) 직인이있는식당 : 서빙직원,요리직원,재료직원 각 역할별로 담당한다.
            ( 담당자에게 빠른 처리를 요구할수있다.)
    6. 사용처 : 다양한 실무 프레임워크(Spring) 에서 권장하는 패턴이다.
    7. 레이어/계층
        V(view)         : 입출력 담당
            1) 주로 웹/앱 에서는 HTML/CSS/JS/JSP/REACT/플러터(프론트엔드)
            2) 사용자로부터 입력과 출력 받는다.
            3) 관례적인 규칙 ( console ) view클래스에서만 print함수와 scan함수를 사용한다.

        C(controller)   : model 과 view 사이의 제어/전달/유효성검사/로직 담당
            1) 주로 웹/앱 에서는 JAVA/PYTHON/NODE.JS ( 백엔드 )
            2. 사용자로부터(VIEW) 부터 요청를 받아 model 에게 전달하고 처리 결과를 view 에게 전달한다.
            3) 주요 키워드
                MVC1 패턴                 : JSP(controller+view) , model
                MVC2 패턴                 : controller , view , model             [V]
                MVC2 패턴 3티어(Spring)   : controller , service , view , model
        M(model)        : 데이터 관리 담당
            1) 주로 웹/앱 에서는 JAVA/PYTHON/NODE.JS ( 백엔드 )
            2) 데이터베이스 상호작용
            3) 주요 키워드
                DAO( data access object ) : 데이터에 접근 객체  : ex] 물류 센터
                DTO( data transfer object ) : 데이터를 이동 객체 : ex] 택시 기사
            4) 관례적인 규칙
                DTO 에는 데이터모델 이므로 싱글톤을 사용하지 않는다.

    8. 레이어/계층 간의 흐름도
        [주문]
            주문 요청 : 콜라 하나 주세요.
                VIEW ---DTO---> controller ---DTO---> model(DAO)
            주문 응답 : 콜라 하나 줄게요.
                VIEW <---DTO--- controller <---DTO--- model(DAO)

    9. 파일/폴더 MVC 기준 구분
        - 프로젝트 폴더
            - controller 폴더
                MemberController
                BoardController
            - model 폴더
                -> dao 폴더
                    MemberDao
                    BoardDao
                -> dto 폴더
                    MemberDto
                    BoardDto
            - view 폴더 * 추후에 HTML 로 변경 된다.
                MemberView
                BoardView
            - AppStart 클래스

-------------------------------------------------------------------------------------------------
IDE(통합 개발 환경)
	- VSCODE( 주로 HTML/CSS/JS )
	- 인텔리제이( 젯브레인 : 자바/파이썬 개발환경 )

[ 인텔리제이 ]
	1. https://www.jetbrains.com/ko-kr/idea/
	2. [다운로드]
	3. IntelliJ IDEA Community Edition ( 다운로드 )
	--- ideaIC-2025.1.3.exe 다운로드 진행 , 설치옵션( 모두 체크 )

[ 인텔리제이 자바 프로젝트 생성 ]
	1. 인텔리제이 실행
	2. [ 새 프로젝트 ] 클릭
		이름 : tj2025A_backend ( 프로젝트 폴더명 ) * 아무거나
		위치 : ~\Desktop
		* [체크안함] git 저장소 생성
		시스템 빌드 : intellij
		JDK :
			1. JDK 다운로드
				버전 : 17
				공급업체 : Amazon Corretto ( 아무거나 )
				위치 : (기본값)
	3. [생성]

[ 인텔리제이 기본 세팅 ]
	*. 파일 -> 설정 -> 사이드바 메뉴 :
	1. 모양 및 동작 -> 모양
		테마 : 눈 피로도 에 따라 선택 *그외
	2. 에디터 -> 일반
		ctrl + 마우스 휠
	3. 플러그인 -> 외부 프로그램 설치 ( *추후 )
[ 인텔리제이 프로젝트 구성 ]
	- 프로젝트명 ( tj2025A_backend )
		.idea ( 인텔리제이 설정파일 - 관리대상x )
		.out( 자바 실행 결과파일 - 관리대상x )
		.src( 개발자가 작성한 코드 파일 - 관리대상o ) ******

-------------------------------------------------------------------------------------------------
[ 데이터베이스 ]
    - 데이터(자료) , 베이스(모임/집합)
    1. 정의 : 자료들의 집합
    2. 종류
        1) 관계형 데이터베이스 : 표(테이블) 형식*  : ORACLE
        2) NOSQL 데이터베이스 : 객체 형식         : MONGODB
    3. 목적
        1) 데이터의 체계적인 관리
        2) 데이터 중복 최소화 와 일관된 데이터 ( 무결성 )
        3) 동시 접근 과 공유 ( 서버 )
        4) 보안

[ 관계형 데이터베이스 ] * 실무에서 점유율 높다.
    1. 정의 :
        1) 행(가로) 과 열(세로) 이루어진 데이터의 집합 , 표/테이블
        2) 테이블(표)을 고유/식별(PK) 값을 참조하여 다른 테이블 간의 종속되는 관계 표현
    2. 소프트웨어 정류 (DBMS)
        1. Oracle 2. MySQL 3.MariaDB 등등 * 면접에서 종류 차이 없다.
    3. 필수 용어
        1. DB : 데이터베이스 , 자료의 집합 , ex) 폴더 또는 파일
        2. DBA : 데이터베이스 관리자 , 자료 관리자
        3. DBMS : 데이터베이스 관리 시스템
        4. DB SERVER : 데이터베이스가 설치된 PC
            * SERVER(서버) : 자료를 제공 하는
            * CLIENT(클라이언트) : 자료를 제공 받는
        5. SQL : 데이터베이스 를 조작하기 위한 *언어*
        [ PC ] <------ DMBS <------- [PC2]
        DB             SQL            DBA
        - 즉] 관리자(DBA)는 DBMS 를 이용하여 특정한 PC의 DB를 조작한다.
[ SQL ]
    1. 정의 : 데이터베이스 에서 데이터를 추출 하고 조작하는데 사용되는 프로그램 언어
    2. 주요 SQL
        1) DDL : 데이터베이스 정의 언어
        2) DML : 데이터베이스 조작 언어
        3) DCL : 데이터베이스 제어 언어
        4) TCL : 트랜잭션 제어 언어

[ 데이터베이스(MYSQL ) 설치 ]
    [ exe 파일 받기 ]
        1. MYSQL 다운로드 링크 접속 ,
            https://dev.mysql.com/downloads/
        2. [ https://dev.mysql.com/downloads/installer ] 메뉴 클릭
        3.
            Select Version: 8.x
            Select Operating System: Windows
                - Windows (x86, 32-bit), MSI Installer	8.0.42	353.7M	[ Download ] 클릭
        4. [No thanks, just start my download.] 클릭
    [ 설치파일 실행 ]
        1. mysql-installer-community-8.x 실행
        2. [custom] 선택 -> [next]
        3. 2가지를 오른쪽으로 이동 후 --> [next]
            1. [서버] MySQL server 8.xx
            2. [DB통합관리] application -> MYSQL Workbench 8.xx
        3. -> [next] -> [excute] -> [next] -> [next]
        4. type and networking 확인후 -> [next] -> [next]
            port : 3306 ( *접속 번호-변경 하지 않기 )
        5. accounts and roles 비밀번호 지정후 -> [next] -> [next] -> [next] -> [excute] -> [finish]
            password : 1234 ( 학원 이므로 1234 해주세요. )
        6. -> [next] -> [finish]
    [ workbench 이용하여 설치된 DB 서버에 접속하기 ]
        1. 윈도우메뉴 -> MySQL Workbench 8.0 CE 바탕화면 바로바기 만들기
        2. MySQL Workbench 8.0 실행
        3. 메인화면에 [ Local instance MySQL80 ] 구역이 있으면 성공 --> 클릭 --> 패스워드 입력후 [ok]

----------------------------------------------------------------------------------------------------
[ 데이터베이스 ] : 데이터/자료들의 집합/모임
[ 관계형데이터베이스 ] : 자료들 간의 종속되는 관계 표현 가능한 데이터베이스
[ 테이블 ] : 행 과 열로 이루어진 데이터의 형식 = 표
[ SQL ]
    - 주의할점
        1) SQL 대소문자를 구분하지 않는다.
        2) SQL 명령어 문장 끝에(;)세미콜론 단위로 실행한다.
    [0] 메타데이터 관리어
        1. show
            1) show databases;                      : DB서버내 전체 데이터베이스 목록 조회
            2) show variables like 'datadir';       : DB서버내 LOCAL PATH 조회
            3) show tables;                         : *활성화*중인 데이터베이스내 모든 테이블 조회
        2. use
            1) use 데이터베이스명;                     : DB서버내 지정한 데이터베이스 활성화(사용)
    [1] 데이터베이스 정의어 : DDL
        1. create
            1) create database 데이터베이스명;         : 지정한 데이터베이스 생성
            2) create table 테이블명(                 : 지정한 테이블 생성
                    속성명1 타입 제약조건 ,
                    속성명2 타입 제약조건
                );
        2. drop
            1) drop database 데이터베이스명;           : 지정한 데이터베이스 삭제
            2) drop database if exists 데이터베이스명; : 만약에 지정한 데이터베이스 존재하면 삭제
            3) drop table 테이블명;                   : 지정한 테이블 삭제
            4) drop table if exists 테이블명;         : 만약에 지정한 테이블 존재하면 삭제

    [2] 데이터베이스 조작어 : DML , 키워드/문법에 대한 대소문자 구분 없다.
        1. INSERT
            1) 특정 속성에 값 대입하여 레코드 추가
                insert into 테이블명( 속성명1, 속성명2) values( 값1, 값2 );
            2) 모든 속성에 값 대입하여 레코드 추가 , 속성명 생략 가능
                insert into 테이블명 values( 값1, 값2 );
            3) 하나의 insert 로 여러개 레코드 추가
                insert into 테이블명 values( 값1, 값2 ), (값1, 값2), (값1, 값2);
            - 주의할점 : 각 속성의 제약조건에 따라 적절하게 값 대입
        2. SELECT
            1) 전체 속성에 레코드 조회 , *(와일드카드)
                select * from 테이블명;
            2) 특정 속성에 레코드 조회
                select 속성명1 , 속성명2 from 테이블명
            3) 특정 속성 조건에 따른 레코드 조회
                select * from 테이블명 where [조건절];
        3. UPDATE
            1) 전체 레코드의 속성값 수정
                update 테이블명 set 속성명 = 새로운값;
            2) 특정 속성 조건에 따른 레코드의 속성값 수정
                update 테이블명 set 속성명 = 새로운값 where [조건절];
            3) 다수 속성값 수정
                update 테이블명 set 속성명 = 새로운값 , 속성명 = 새로운값 where [조건절];
        4. DELETE
            1) 전체 레코드 삭제
                delete from 테이블명;
            2) 특정 속성 조건에 따른 레코드 삭제
                delete from 테이블명 where [조건절];

        * mysqlWorkbench safeMode(수정/삭제금지) : pc마다 첫 설치 이후 safeMode 켜져 있음.
        -> 수정/삭제시 safeMode 끄기 : set SQL_SAFE_UPDATES = 0



[데이터 타입] : 테이블내 속성들이 갖는/저장하는 자료들의 분류/타입/종류
    1. 정수
        tinyint     1바이트    -128 ~ +127
        smallint    2바이트    +-3만정도
        mediumint   3바이트    +-800만정도
        int         4바이트    +-21억정도
        bigint      8바이트    +-21억이상
            * signed : 부호가 있다( +양수 -음수 ) 기본값
                - unsigned : 부호가 없다( 허용범위 x2 )
                - int unsigned : 42억까지(대신 음수 없다.)
    2. 실수
        float       4바이트    소수점
        double      8바이트    소수점
        decimal     문자타입   소수점을 문자로 처리하는 타입, 오차없음
    3. 날짜/시간
        date        날짜표현        2025-07-15
        time        시간표현        10:02:30
        datetime    날짜/시간표현    2025-07-15 10:02:30
    4. 문자
        char(길이)   문자열표현    고정길이 최대255글자 , char(5) -> "유재석"     --> [유] [재] [석] [ ] [ ]
        varchar(길이)문자열표현    가변길이 최대255글자 , varchar(5) -> "유재석"  --> [유] [재] [석] 남은길이삭제
        text        문자열표현     최대 6만글자
        longtext    문자열표현     최대 42억개 글자 , 4GB , 대용량
    5. 논리
        bool        논리표현       true 혹은 false , tinyint 와 같다. 0/1

[ 제약조건 ] : 테이블내 속성의 *제약조건
    1. not null         : 해당 속성에 null 값을 저장하지 않는다.
    2. unique           : 해당 속성에 중복값을 허용하지 않는다.(중복방지)
    3. default 기본값    : 해당 속성에 값 생략시 기본값으로 초기화한다.
        default 0       : 해당 속성에 값이 생략되면 0 초기화한다.
        default now()   : 해당 속성에 값이 생략되면 현재 날짜/시간 초기화한다.
    4. auto_increment   : (MYSQL) 해당 속성에 순서대로 자동번호 초기화한다. ( + primary key )
    5. primary key      : 기본/식별키(PK) , 식별 가능한 고유 값 필드 키
        -> 학번,사번,회원번호,주문번호,제품번호,게시물번호,예약번호 등등
        -> 절대적으로 중복이 없는 고유 값 !!!!!!
        특징) not null , unique 포함됨.
        선언) constraint primary key( PK필드명 )

    6. foreign key      : 참조/외래키(FK) , 다른 테이블의 기본키(PK)를 참조하는 키
        -> 수강신청한학번, 출근한직원사번 , 글작성자회원번호 등등
        특징) FK필드는 NULL 과 중복 이 가능하다. PK값 참조한다.
        선언) constraint foreign key( FK필드명 ) references 참조할테이블명( PK필드명 );
        주의할점)
            1. FK속성타입 과 PK속성타입 일치 한다.
            2. 관례적으로 pk속성명 과 fk속성명은 동일하게 한다.

[ 생성된 테이블 다이어그램 확인 ] : 여럿 테이블 간의 관계 확인
    #  workbench 상단메뉴 -> [database] -> [reverse engineer] -> stored conntion : local(선택) -> [next]
    # -> 비밀번호입력 [next] -> 데이터베이스 선택 -> [next] -> [finish]


[ 키워드 ]
    1. 별칭 : as
        select 속성명 as 별칭 from 테이블명 as 별칭
        select 속성명 별칭 from 테이블명 별칭
    2. 중복제거 : distinct
        select distinct 속성명 from 테이블명
[ 연산자 ]
    1. 산술연산자 : +더하기 -빼기 *곱하기 /나누기 div몫 mod나머지
        select (산술) from 테이블명 where (산술)
    2. 비교연산자 : >초과 <미만 >=이상 <=이하 =같다 !=같지않다
        select 속성명 from 테이블명 where (비교)
    3. 논리연산자 : and이면서 or이거나 not부정
        select 속성명 from 테이블명 where (논리)
    4. 기타연산자
        (1) select 속성명 from 테이블명 where 속성명 between 시작값 and 끝값
        (2) select 속성명 from 테이블명 where 속성명 in( 값1 , 값2 )
    5. null연산자
        (1) select 속성명 from 테이블명 where 속성명 is null
        (2) select 속성명 from 테이블명 where 속성명 is not null
    6. 문자패턴
        (1) 속성명 like '%'    : 모든문자대응 , 제한없음
            select 속성명 from 테이블명 where 이름 like '김%';    김씨 찾기 , 김x 김xx 김xxx 김xxxx
        (2) 속성명 like '_'    : 모든문자대응 , _개수만큼 문자조회
            select 속성명 from 테이블명 where 이름 like '김__';    김씨 찾기 , 김xx
[ 정렬 ]
    1. order by 속성명 asc     : 오름차순 , asc/desc 생략시 기본값
    2. order by 속성명 desc    : 내림차순
    * 주의할점 : 2차 정렬부터는 앞 정렬의 동일한 레코드끼리 정렬
    select 속성명 from 테이블명 order by 학급 asc , 점수 desc;     학급 먼저 정렬후 동일한 학급끼리 점수 정렬

[ 조회결과 제한 ]
    1. limit 레코드수
    2. limit 시작레코드번호(0) , 개수
    * 주로 페이징처리 사용됨.
    select 속성명 from 테이블명 limit 0 , 10;  [1페이지]
    select 속성명 from 테이블명 limit 10 , 10; [2페이지]
    select 속성명 from 테이블명 limit 20 , 10; [3페이지]

[ 키워드 작성 순서 ]
    [select] 속성명 [from] 테이블명 [where] 조건절 [order by] 속성명 asc/desc [limit] 개수;
